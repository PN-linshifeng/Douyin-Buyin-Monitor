const fs = require('fs-extra');
const path = require('path');
const JavaScriptObfuscator = require('javascript-obfuscator');

const DIST_DIR = path.join(__dirname, 'dist');
const EXTENSION_SRC_NAME = 'buyin_monitor_extension';
const BACKEND_SRC_NAME = 'buyin_monitor_backend';

const EXTENSION_SRC = path.join(__dirname, EXTENSION_SRC_NAME);
const BACKEND_SRC = path.join(__dirname, BACKEND_SRC_NAME);

// Configuration for obfuscation
const OBFUSCATOR_OPTIONS = {
	compact: true,
	controlFlowFlattening: true,
	controlFlowFlatteningThreshold: 0.75,
	deadCodeInjection: false,
	debugProtection: false,
	disableConsoleOutput: true, // This helps remove console.* calls generated by code, but we do manual removal too
	identifierNamesGenerator: 'hexadecimal',
	log: false,
	renameGlobals: false,
	rotateStringArray: true,
	selfDefending: false,
	stringArray: true,
	stringArrayEncoding: ['base64'],
	stringArrayThreshold: 0.75,
	transformObjectKeys: true,
	unicodeEscapeSequence: false,
	target: 'browser-no-eval', // Service workers don't support eval
};

// Filter function to exclude node_modules, .git, .env, .DS_Store
const copyFilter = (src, dest) => {
	const basename = path.basename(src);
	if (
		basename === 'node_modules' ||
		basename === '.git' ||
		basename === '.env' ||
		basename === '.DS_Store' ||
		basename.endsWith('.log') ||
		basename.endsWith('.md')
	) {
		return false;
	}
	return true;
};

async function build() {
	console.log('Starting build process...');

	// 1. Clean dist directory
	await fs.emptyDir(DIST_DIR);
	console.log('Cleaned dist directory.');

	// 2. Copy buyin_monitor_extension
	console.log(`Copying ${EXTENSION_SRC_NAME}...`);
	await fs.copy(EXTENSION_SRC, path.join(DIST_DIR, EXTENSION_SRC_NAME), {
		filter: copyFilter,
	});

	// 2.1 Update manifest.json (remove '测试' from name)
	const manifestPath = path.join(DIST_DIR, EXTENSION_SRC_NAME, 'manifest.json');
	if (await fs.pathExists(manifestPath)) {
		console.log('Updating manifest.json name...');
		const manifest = await fs.readJson(manifestPath);
		if (manifest.name && manifest.name.includes('测试')) {
			manifest.name = manifest.name.replace('测试', '');
			await fs.writeJson(manifestPath, manifest, {spaces: 2});
		}
	}

	// 3. Copy buyin_monitor_backend
	console.log(`Copying ${BACKEND_SRC_NAME}...`);
	await fs.copy(BACKEND_SRC, path.join(DIST_DIR, BACKEND_SRC_NAME), {
		filter: copyFilter,
	});

	// 4. Process JS files in buyin_monitor_extension (root of that dir)
	const distExtensionDir = path.join(DIST_DIR, EXTENSION_SRC_NAME);
	await processDirectory(distExtensionDir, true); // true = isExtension

	// 5. Process JS files in buyin_monitor_backend/public/extension
	const distBackendExtensionDir = path.join(
		DIST_DIR,
		BACKEND_SRC_NAME,
		'public/extension'
	);
	await processDirectory(distBackendExtensionDir, false);

	console.log('Build complete! Output in dist/');
}

async function processDirectory(dirPath, isExtension = false) {
	if (!(await fs.pathExists(dirPath))) {
		console.warn(`Directory not found: ${dirPath}`);
		return;
	}

	const files = await fs.readdir(dirPath);
	for (const file of files) {
		const fullPath = path.join(dirPath, file);
		const stat = await fs.stat(fullPath);

		if (stat.isDirectory()) {
			// 如果是 plugins 目录，跳过处理 (即不进入混淆流程，保留原始文件)
			// 注意：fs.copy 已经将文件复制过去了，这里只是决定是否要读取并混淆覆盖
			if (file === 'plugins') {
				console.log(`Skipping obfuscation for directory: ${file}`);
				continue;
			}
			// 递归处理其他目录
			await processDirectory(fullPath, isExtension);
		} else if (file.endsWith('.js')) {
			await processFile(fullPath, isExtension);
		}
	}
}

async function processFile(filePath, isExtension = false) {
	try {
		console.log(`Processing: ${path.relative(DIST_DIR, filePath)}`);
		let content = await fs.readFile(filePath, 'utf8');

		// 1. Remove all console statements (log, debug, info, warn, error, etc.)
		// Regex to match console.xxx(...) including multi-line
		// Matches: console.method ( ... ) ;?
		content = content.replace(
			/console\.\w+\s*\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)\s*;?/g,
			''
		);

		// 2. Remove "console debug" comments (User said: "删除console debug 注释")
		// This is tricky. I'll remove single line comments containing "console debug" (case insensitive)
		content = content.replace(/\/\/.*console\s*debug.*/gi, '');
		// Also remove block comments containing it? Obfuscator removes all comments anyway.
		// Javascript-obfuscator removes comments by default unless options.comments is true.
		// So generic comment removal is handled by obfuscator.

		// 3. Replace Backend URL (User Request: Local -> Remote)
		if (content.includes('http://127.0.0.1:3308')) {
			console.log(`Replacing backend URL in ${path.basename(filePath)}...`);
			content = content.replace(
				/http:\/\/127\.0\.0\.1:3308/g,
				'http://54.151.167.242:3308'
			);
		}

		// 4. Pre-obfuscation Fix for background.js
		// Prevent obfuscation of the function injected via executeScript
		if (path.basename(filePath) === 'background.js') {
			console.log('Applying pre-obfuscation patch to background.js...');
			content = content.replace(
				'func: (codeContent) => {',
				'func: /* javascript-obfuscator:disable */ (codeContent) => {'
			);
			content = content.replace(
				'args: [code],',
				'/* javascript-obfuscator:enable */ args: [code],'
			);
		}

		// 4. Obfuscate
		const obfuscationResult = JavaScriptObfuscator.obfuscate(
			content,
			OBFUSCATOR_OPTIONS
		);
		let obfuscatedCode = obfuscationResult.getObfuscatedCode();

		// 5. FIX: Handle background.js running as Service Worker (no window)
		// If this is background.js, replace potential window references in boilerplate with self
		if (path.basename(filePath) === 'background.js') {
			console.log('Patching background.js for Service Worker environment...');
			// Naive but effective for obfuscator boilerplate: replace window with self
			// Only if original code didn't use window (which it shouldn't for SW)
			// We use a global replace for 'window' -> 'self'
			// Note: This might break if strings contain 'window', but in obfuscated code strings are usually in string array.
			// However, obfuscator might put window in the logic.
			// Warning: this is aggressive.
			obfuscatedCode = obfuscatedCode.replace(/window/g, 'self');
		}

		await fs.writeFile(filePath, obfuscatedCode);
	} catch (err) {
		console.error(`Error processing ${filePath}:`, err);
	}
}

build().catch((err) => console.error(err));
